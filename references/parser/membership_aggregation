##-- Membership aggregation with upstream in rulematching first and mutex --##

#                          
#     \           /                  
#      \         /                   
#       \       /                    
#      +---------+         
#      | U1   U2 |         
#      |    D    |         
#      +---------+         
#           |    
#           |    
#           |    
#

#Naming and definitions
sX:          is a specific multicast source (where X could be 1 or 2 or ...)
S:           is a list of multicast sources (sX) 
Sg:          is a multicast source list with the group membership mode INCLUDE or EXCLUDE 
Sf:          is a multicast source list with with the inteface filter mode WHITELIST or BLACKLIST 
IN(S):       is a source list Sg in group membership mode INCLUDE
EX(S):       is a source list Sg in group membership mode EXCLUDE
WL(S):       is a source list Sf in in interface filter mode WHITELIST
BL(S):       is a source list Sf in interface filter mode BLACKLIST 
P:           is the position UPSTREAM or DOWNSTREAM of an interface 
I(P,Sg,Sf):  is an interfaces with a Position and and two source lists. One with a specific group membership mode and one an interface filter mode. 
D(Sg,Sf):    is an interface with a DOWNSTREAM Position 
U(Sg,Sf):    is an interface with an UPSTREAM Position
Dm(Sg):      is a DOWNSTREAM interface with merged list Sg and Sf              
Dmall(Sg):   represent all result amerged group membership with interface filter 
R(Sg):       is the remainder of a merge operation

#Operations
+:  unit        ({s1,s2} + {s2,s3} = {s1,s2,s3} remainder{})
*: intersection ({s1,s2} * {s2,s3} = {s2} remainder{s1,s3})
-: without      ({s1,s2} - {s2,s3} = {s1} remainder{s2,s3})

#Merge group memberships Sg + Sg ==> Sg
#A(group membership) and B(group membership) = Result(visible membership), Remainder ==> howto calculate
IN(S1,S2) and IN(S1,S3) = IN(S1,S2,S3) ==> IN(A + B)
IN(S1,S2) and EX(S1,S3) = EX(S3) ==> EX(B - A)
EX(S1,S2) and IN(S1,S3) = EX(S2) ==> EX(A - B)
EX(S1,S2) and EX(S1,S3) = EX(S1) ==> EX(A * B)

#ASM
Join: EX({})
Leave: IN({})

#Merge group membership with interface filter
#A(group membership) and B(interface filter) = Result(visible membership), Remainder ==> howto calculate
IN(S1,S2) and WL(S1,S3) = IN(S1), R(IN(S2)) ==> IN(A * B), R(IN(A - Result))
IN(S1,S2) and BL(S1,S3) = IN(S2), R(IN(S1)) ==> IN(A - B), R(IN(A - Result))
EX(S1,S2) and WL(S1,S3) = IN(S3), R(EX(S1,S2,S3) ==> IN(B - A), R(EX(A + Result))
EX(S1,S2) and BL(S1,S3) = EX(S1,S2,S3), R(IN(S3)) ==> EX(A + B), R(IN(Result - A))  

IN(S1,S2) and BL({}) = IN(S1,S2), R(IN({}))

#processing tool chain -- upstream in rulematching first
1. merge D group membership with D interface filter ==> Dall 
2. merge Dall with U1 interface filter ==> U1 membership aggregation, R 
3. merge R with U2 interface filter ==> U2 membership aggregation

#processing tool chain -- upstream in rulematching mutex 
#Examples -- upstream in rulematching first
1. merge D group membership with D interface filter ==> Dall 
2. calculate the Mutex Blacklist for every upstream (all received sources form all interfaces (D, U1, U2) without the sources of the own interface)  ==> M_BL_U1, M_BL_U2
3. merge Dall with U1 interface filter and with M_BL_U1 ==> U1 membership aggregation 
4. merge Dall with U2 interface filter and with M_BL_U2 ==> U2 membership aggregation 


HINT: Dall has to be calculated for every Downstream and merged after the processing tool chain

#Example -- upstream in rulematching first
#Downstream status | Upstream status ==> Membership Aggregation
Dall: IN(S1,S2) | U1: WL(S1), U2: WL(S2) ==> U1: IN(S1), U2: IN(S2)
Dall: IN(S1,S2) | U1: BL(S1), U2: BL(S2) ==> U1: IN(S2), U2: IN(S1)
...

#Example -- upstream in rulematching mutex 
#Downstream status | Upstream status ==> Membership Aggregation


